//
//  File.swift
//  
//
//  Created by k-kohey on 2022/12/30.
//

import Foundation
import Parchment

public struct SwiftGenerator {
    enum Error: Swift.Error {
        case argumentsIsEmpty
    }

    public init() {}

    public func run(with definisions: [EventDefinision]) throws -> String {
        guard !definisions.isEmpty else { throw Error.argumentsIsEmpty }
        return generate(with: definisions)
    }

    private func generate(with definisions: [EventDefinision]) -> String {
        """
        // This file is automatically generated by eventgen.
        // Do not edit this file.

        struct GeneratedEvent: \(Loggable.self) {
            let eventName: String
            let paramerters: [String: Sendasble]
        }

        extension GeneratedEvent {
            \(indented: generateFunc(with: definisions.filter { !$0.properties.isEmpty }))
            \(indented: generateProperty(with: definisions.filter { $0.properties.isEmpty }))
        }
        """
    }

    private func generateFunc(with definision: EventDefinision) -> String {
        """
        \(generateCodeDocument(with: definision))
        static func \(definision.name)\(generateTupple(with: definision.properties)) -> Self {
            .init(
                eventName: "\(definision.name)",
                parameters: \(generateParamertersDictonary(with: definision))
            )
        }
        """
    }

    private func generateProperty(with definision: EventDefinision) -> String {
        """
        \(generateCodeDocument(with: definision))
        static var \(definision.name): Self {
            .init(eventName: \(definision.name), parameters: [:])
        }
        """
    }

    private func generateFunc(with definisions: [EventDefinision]) -> String {
        definisions.map(generateFunc(with:)).joined(separator: "\n")
    }

    private func generateProperty(with definisions: [EventDefinision]) -> String {
        definisions.map(generateProperty(with:)).joined(separator: "\n")
    }

    private func generateParamertersDictonary(with definision: EventDefinision) -> String {
        "[\(definision.properties.map { "\($0.name): \($0.name)" }.joined(separator: ", "))]"
    }

    private func generateTupple(with fields: [Field]) -> String {
        func type(_ typeString: String, isNullable: Bool) -> String {
            var result: String
            switch typeString {
            case "string":
                result = "\(String.self)"
            case "int":
                result = "\(Int.self)"
            case "double":
                result = "\(Double.self)"
            case "boolean":
                result = "\(Bool.self)"
            default:
                fatalError("Detect unsupported type \(typeString)")
            }

            if isNullable {
                result += "?"
            }

            return result
        }
        return "(" + fields.map { "\($0.name): \(type($0.type, isNullable: $0.nullable))" }.joined(separator: ", ") + ")"
    }

    private func generateCodeDocument(with definision: EventDefinision) -> String {
        if !definision.properties.isEmpty {
            return """
            /// \(definision.description)
            /// - Parameters:
            \(definision.properties.map { "///   - \($0.name): \($0.description)" }.joined(separator: "\n"))
            """
        } else {
            return """
            /// \(definision.description)
            """
        }
    }
}

private extension DefaultStringInterpolation {
    mutating func appendInterpolation(indented string: String) {
       let indent = String(stringInterpolation: self).reversed().prefix { " \t".contains($0) }
       if indent.isEmpty {
            appendInterpolation(string)
        } else {
            appendLiteral(string.split(separator: "\n", omittingEmptySubsequences: false).joined(separator: "\n" + indent))
        }
    }
}
